import { Component, OnInit, ViewChild } from '@angular/core';
import { ApiService } from 'src/app/services/api.service';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Appointment } from 'src/app/models/appointment.model';
import { BehaviorSubject, Observable } from 'rxjs';
import { MatTableDataSource } from '@angular/material/table';
import { MatSort } from '@angular/material/sort';
import { EditAppointmentDialogComponent } from 'src/app/edit-appointment-dialog/edit-appointment-dialog.component';
import { MatDialog } from '@angular/material/dialog';

@Component({
  selector: 'app-appointments',
  templateUrl: './appointments.component.html',
  styleUrls: ['./appointments.component.scss'],
})
export class AppointmentsComponent implements OnInit {
  dataSource!: MatTableDataSource<Appointment>;
  @ViewChild(MatSort, { static: true }) sort!: MatSort;
  // appointments: any[] = [];
  employees: any[] = [];
  customers: any[] = [];
  services: any[] = [];
  appointmentStatuses: any[] = [];
  appointmentForm: FormGroup;
  // Using BehaviorSubject to manage a stream of appointment data
  private appointmentsSubject = new BehaviorSubject<any[]>([]);
  appointments$!: Observable<any[]>; // Observable for MatTable dataSource
  displayedColumns: string[] = [
    'appointmentDate',
    'employee',
    'customer',
    'service',
    'price',
    'appointmentStatus',
    'actions',
  ];

  constructor(
    private _service: ApiService,
    private formBuilder: FormBuilder,
    private fb: FormBuilder,
    public dialog: MatDialog
  ) {
    this.appointmentForm = this.fb.group({
      appointmentDate: [null, Validators.required],
      employeeId: [null, Validators.required],
      customerId: [null, Validators.required],
      serviceId: [null, Validators.required],
      appointmentStatusId: [null, Validators.required],
    });
  }

  ngOnInit() {
    this.fetchRelatedData();
    this._service.getAppointments().subscribe((appointments) => {
      this.appointments$ = this._service.getAppointments();
    });

    this.appointments$.subscribe((appointments) => {
      this.dataSource = new MatTableDataSource(appointments);
      this.dataSource.sort = this.sort;
    });
  }

  fetchRelatedData() {
    // Fetch Employees
    this._service.getEmployees().subscribe(
      (data) => (this.employees = data),
      (error) => console.error('Failed to fetch employees', error)
    );

    // Fetch Customers
    this._service.getCustomers().subscribe(
      (data) => (this.customers = data),
      (error) => console.error('Failed to fetch customers', error)
    );

    // Fetch Services
    this._service.getServices().subscribe(
      (data) => (this.services = data),
      (error) => console.error('Failed to fetch services', error)
    );

    // Fetch Appointment Statuses
    this._service.getAppointmentStatuses().subscribe(
      (data) => (this.appointmentStatuses = data),
      (error) => console.error('Failed to fetch appointment statuses', error)
    );

    // Fetch Appointments
    this._service.getAppointments().subscribe(
      (data) => this.appointmentsSubject.next(data),
      (error) => console.error('Failed to fetch appointments', error)
    );
  }

  addAppointment(): void {
    if (this.appointmentForm.invalid) {
      return; // If the form is invalid, do nothing.
    }

    const formModel = this.appointmentForm.value;

    // Creating the appointment payload according to the backend requirements.
    const appointmentPayload: Appointment = {
      id: 0, // ID is typically generated by the backend
      appointmentDate: formModel.appointmentDate, // Assuming the backend expects ISO string
      employeeId: formModel.employeeId,
      employee: this.employees.find((e) => e.id === formModel.employeeId),
      customerId: formModel.customerId,
      customer: this.customers.find((c) => c.id === formModel.customerId),
      serviceId: formModel.serviceId,
      service: this.services.find((s) => s.id === formModel.serviceId),
      appointmentStatusId: formModel.appointmentStatusId,
      appointmentStatus: this.appointmentStatuses.find(
        (s) => s.id === formModel.appointmentStatusId
      ),
    };

    // Call the API to create an appointment
    this._service.createAppointment(this.appointmentForm.value).subscribe({
      next: (res) => {
        this.appointments$ = this._service.getAppointments();
        this.appointmentForm.reset();
      },
      error: (error) => {
        console.error('Error creating appointment:', error);
        // Error handling logic here, possibly set an error message in the component to display in the template.
      },
    });
  }

  editAppointment(appointment: Appointment): void {
    console.log(this.appointmentStatuses)
    const dialogRef = this.dialog.open(EditAppointmentDialogComponent, {
      width: '800px',
      data: {
        appointment: appointment,
        employees: this.employees,
        customers: this.customers,
        services: this.services,
        status:this.appointmentStatuses
      },
    });

    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        this._service.updateAppointment(result).subscribe({
          next: (updatedAppointment) => {
            // Replace the edited appointment in the appointments list
            // Or re-fetch the appointments list from the server
            this.appointments$ = this._service.getAppointments();
          },
          error: (error) => console.error('Error updating appointment:', error),
        });
      }
    });
  }

  deleteAppointment(appointmentId: number): void {
    // Logic to handle the deletion of an appointment
    console.log('Deleting appointment with ID:', appointmentId);
    // Call the API service to delete the appointment and refresh the list
    this._service.deleteAppointment(appointmentId).subscribe(() => {
      // After successful deletion, refresh the list
      this.appointments$ = this._service.getAppointments();
    });
  }
}
